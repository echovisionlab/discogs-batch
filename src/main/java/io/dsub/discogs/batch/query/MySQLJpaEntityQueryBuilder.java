package io.dsub.discogs.batch.query;

import io.dsub.discogs.common.entity.base.BaseEntity;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.persistence.Column;

public class MySQLJpaEntityQueryBuilder extends SqlJpaEntityQueryBuilder<BaseEntity> {

  public static final String ON_DUPLICATE_KEY_UPDATE_FORMAT = "ON DUPLICATE KEY UPDATE %s";

  public static final String INSERT_IGNORE_INTO_FORMAT = "INSERT IGNORE INTO %s(%s) SELECT %s";

  @Override
  public String getUpsertQuery(Class<? extends BaseEntity> targetClass) {
    String insertClause = getInsertQuery(targetClass);
    boolean idAutoGenerated = isIdAutoGenerated(targetClass);
    boolean hasUniqueConstraints = hasUniqueConstraints(targetClass);
    if (idAutoGenerated && !hasUniqueConstraints) {
      return insertClause;
    }

    Field lastModified = getLastModifiedField(targetClass);
    Field createdAt = getCreatedAtField(targetClass);

    Stream<Map.Entry<String, String>> stream;
    if (idAutoGenerated) {
      stream = getMappingsOutsideUniqueConstraints(targetClass, false).entrySet().stream();
    } else {
      stream = getMappings(targetClass, false).entrySet().stream();
    }

    String upsertClause =
        stream
            .filter(entry -> createdAt == null || !entry.getValue().equals(createdAt.getName()))
            .map(entry -> makeUpdateSetMapping(entry.getKey(), entry.getValue(), lastModified))
            .collect(Collectors.joining(","));

    if (hasJoinColumns(targetClass)) {
      insertClause += SPACE + getRelationExistCountingWhereClause(targetClass);
    }

    return insertClause + SPACE + String.format(ON_DUPLICATE_KEY_UPDATE_FORMAT, upsertClause);
  }

  @Override
  public String getIdOnlyInsertQuery(Class<? extends BaseEntity> targetClass) {
    Map<String, String> idMappings = getIdMappings(targetClass);
    Field lastModified = getLastModifiedField(targetClass);
    Field createdAt = getCreatedAtField(targetClass);

    if (lastModified != null) {
      idMappings.put(lastModified.getAnnotation(Column.class).name(), lastModified.getName());
    }
    if (createdAt != null) {
      idMappings.put(createdAt.getAnnotation(Column.class).name(), createdAt.getName());
    }

    String columns = String.join(",", idMappings.keySet());
    String fields =
        getFormattedValueFields(createdAt, lastModified, new ArrayList<>(idMappings.values()));
    String tblName = getTableName(targetClass);
    return String.format(DEFAULT_SQL_INSERT_QUERY_FORMAT, tblName, columns, fields);
  }

  private String makeUpdateSetMapping(String key, String value, Field lastUpdateAt) {
    if (lastUpdateAt != null && value.equals(lastUpdateAt.getName())) {
      return key + EQUALS + "NOW()";
    }
    return key + EQUALS + COLON + value;
  }
}
