package io.dsub.discogsdata.batch.query;

import io.dsub.discogsdata.common.entity.base.BaseEntity;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.stream.Collectors;
import javax.persistence.JoinColumn;
import javax.persistence.Table;
import org.springframework.stereotype.Component;

// todo: consider conditional bean on vendor specific needs
@Component
public class PostgresqlJpaEntityQueryBuilder implements JpaEntityQueryBuilder<BaseEntity> {

  public static final String INSERT_QUERY_FORMAT =
      "INSERT INTO %s(%s) SELECT %s";

  public static final String EXISTS_QUERY_FORMAT =
      "WHERE %s = %s";

  public static final String EXISTS_QUERY_SELECT_FORMAT =
      "(SELECT 1 FROM %s WHERE %s = %s)";

  public static final String ON_CONFLICT_DO_NOTHING =
      "ON CONFLICT DO NOTHING";

  public static final String UPSERT_QUERY_FORMAT = "ON CONFLICT (%s) DO UPDATE SET %s WHERE %s";

  @Override
  public String getInsertQuery(Class<? extends BaseEntity> targetClass) {
    boolean idInclusive = !isIdAutoGenerated(targetClass);
    Map<String, String> mappings = getMappings(targetClass, idInclusive);
    String tblName = getTableName(targetClass);
    List<String> columns = new ArrayList<>(mappings.keySet());
    List<String> values = new ArrayList<>(mappings.values());

    Field createdAt = getCreatedAtField(targetClass);
    Field lastModified = getLastModifiedField(targetClass);

    for (int i = 0; i < values.size(); i++) {
      String origin = values.get(i);
      if (createdAt != null && origin.equals(createdAt.getName())) {
        values.set(i, "NOW()");
      } else if (lastModified != null && origin.equals(lastModified.getName())) {
        values.set(i, "NOW()");
      } else {
        values.set(i, COLON + origin);
      }
    }

    return String.format(
        INSERT_QUERY_FORMAT,
        tblName,
        String.join(",", columns),
        String.join(",", values));
  }

  @Override
  public String getUpsertQuery(Class<? extends BaseEntity> targetClass) {
    String insertClause = getInsertQuery(targetClass) + SPACE;
    boolean idAutoGenerated = isIdAutoGenerated(targetClass);
    boolean hasUniqueConstraints = hasUniqueConstraints(targetClass);
    if (idAutoGenerated && !hasUniqueConstraints) {
      return insertClause;
    }

    String upsertClause = String.format(
        UPSERT_QUERY_FORMAT,
        getOnConflictCols(targetClass),
        getUpdateClause(targetClass),
        getWhereClause(targetClass));

    if (!hasJoinColumns(targetClass)) {
      return String.join(SPACE, insertClause, upsertClause);
    }
    return String.join(SPACE, insertClause, getExistsQuery(targetClass), upsertClause);
  }

  @Override
  public String getIdOnlyInsertQuery(Class<? extends BaseEntity> targetClass) {
    String tblName = getTableName(targetClass);
    Map<String, String> idMap = getIdMappings(targetClass);
    List<String> idColumns = new ArrayList<>(idMap.keySet());
    List<String> idFields = new ArrayList<>(idMap.values());
    Field createdAt = getCreatedAtField(targetClass);
    Field lastModified = getLastModifiedField(targetClass);
    for (int i = 0; i < idFields.size(); i++) {
      String origin = idFields.get(i);
      if (createdAt != null && origin.equals(createdAt.getName())) {
        idFields.set(i, "NOW()");
      } else if (lastModified != null && origin.equals(lastModified.getName())) {
        idFields.set(i, "NOW()");
      } else {
        idFields.set(i, COLON + origin);
      }
    }
    String query = String.format(INSERT_QUERY_FORMAT,
        tblName,
        String.join(",", idColumns),
        String.join(",", idFields));
    return String.join(SPACE, query, ON_CONFLICT_DO_NOTHING);
  }

  private String getExistsQuery(Class<? extends BaseEntity> targetClass) {
    List<String> innerSelects = getFields(targetClass).stream()
        .filter(field -> field.isAnnotationPresent(JoinColumn.class))
        .map(field -> {
          JoinColumn joinColumn = field.getAnnotation(JoinColumn.class);
          String tblName = field.getType().getAnnotation(Table.class).name();
          return String
              .format(EXISTS_QUERY_SELECT_FORMAT, tblName, joinColumn.referencedColumnName(),
                  COLON + field.getName());
        })
        .collect(Collectors.toList());
    int count = innerSelects.size();
    return String
        .format(EXISTS_QUERY_FORMAT, String.join(SPACE + PLUS + SPACE, innerSelects), count);
  }

  private String getWhereClause(Class<? extends BaseEntity> targetClass) {
    String tblName = getTableName(targetClass);
    boolean idAutoGenerated = isIdAutoGenerated(targetClass);
    boolean hasUniqueConstraints = hasUniqueConstraints(targetClass);
    if (idAutoGenerated && hasUniqueConstraints) {
      return getUniqueConstraintColumns(targetClass).entrySet().stream()
          .map(this::wrapColumnFieldByEquals)
          .map(wrapped -> tblName + PERIOD + wrapped)
          .collect(Collectors.joining(SPACE + AND + SPACE));
    }

    if (!idAutoGenerated && hasUniqueConstraints) {
      Map<String, String> colFieldMap = getUniqueConstraintColumns(targetClass);
      colFieldMap.putAll(getIdMappings(targetClass));
      return colFieldMap.entrySet().stream()
          .map(this::wrapColumnFieldByEquals)
          .map(wrapped -> tblName + PERIOD + wrapped)
          .collect(Collectors.joining(SPACE + AND + SPACE));
    }

    return getIdMappings(targetClass).entrySet().stream()
        .map(this::wrapColumnFieldByEquals)
        .map(wrapped -> tblName + PERIOD + wrapped)
        .collect(Collectors.joining(SPACE + AND + SPACE));
  }

  private String getOnConflictCols(Class<? extends BaseEntity> targetClass) {
    boolean idAutoGenerated = isIdAutoGenerated(targetClass);
    boolean hasUniqueConstraints = hasUniqueConstraints(targetClass);
    if (idAutoGenerated && hasUniqueConstraints) {
      return String.join(",", getUniqueConstraintColumns(targetClass).keySet());
    }
    if (!idAutoGenerated && hasUniqueConstraints) {
      Set<String> cols = new HashSet<>(getUniqueConstraintColumns(targetClass).keySet());
      cols.addAll(getIdMappings(targetClass).keySet());
      return String.join(",", cols);
    }
    return String.join(",", getIdMappings(targetClass).keySet());
  }

  private String wrapColumnFieldByEquals(Entry<String, String> entry) {
    return entry.getKey() + EQUALS + COLON + entry.getValue();
  }

  private String getUpdateClause(Class<? extends BaseEntity> targetClass) {
    boolean idAutoGenerated = isIdAutoGenerated(targetClass);
    boolean hasUniqueConstraints = hasUniqueConstraints(targetClass);
    Field lastModified = getLastModifiedField(targetClass);
    Field createdAt = getCreatedAtField(targetClass);
    if (idAutoGenerated && hasUniqueConstraints) {
      return getMappingsOutsideUniqueConstraints(targetClass, false).entrySet().stream()
          .filter(entry -> createdAt == null || !entry.getValue().contains(createdAt.getName()))
          .map(entry -> makeUpdateSetMapping(entry.getKey(), entry.getValue(), lastModified))
          .collect(Collectors.joining(COMMA));
    }
    return getMappings(targetClass, false).entrySet().stream()
        .filter(entry -> createdAt == null || !entry.getValue().contains(createdAt.getName()))
        .map(entry -> makeUpdateSetMapping(entry.getKey(), entry.getValue(), lastModified))
        .collect(Collectors.joining(COMMA));
  }

  private String makeUpdateSetMapping(String key, String value, Field lastUpdateAt) {
    if (lastUpdateAt != null && value.equals(lastUpdateAt.getName())) {
      return key + EQUALS + "NOW()";
    }
    return key + EQUALS + COLON + value;
  }
}
