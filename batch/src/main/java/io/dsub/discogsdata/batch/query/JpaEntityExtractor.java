package io.dsub.discogsdata.batch.query;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.stream.Collectors;
import javax.persistence.Column;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.Table;
import javax.persistence.Transient;
import javax.persistence.UniqueConstraint;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;

/**
 * Helper interface to support extracting jpa mapping properties from an entity.
 *
 * @param <T>
 */
public interface JpaEntityExtractor<T> {

  default String getTableName(Class<? extends T> targetClass) {
    return targetClass.getAnnotation(Table.class).name();
  }

  default boolean isIdAutoGenerated(Class<? extends T> targetClass) {
    return Arrays.stream(targetClass.getDeclaredFields())
        .filter(field -> field.isAnnotationPresent(Id.class))
        .anyMatch(field -> field.isAnnotationPresent(GeneratedValue.class));
  }

  default Field getLastModifiedField(Class<? extends T> targetClass) {
    return getFields(targetClass).stream()
        .filter(field ->
            field.isAnnotationPresent(LastModifiedDate.class) || field.getName()
                .contains("lastModified"))
        .findFirst()
        .orElse(null);
  }

  default Field getCreatedAtField(Class<? extends T> targetClass) {
    return getFields(targetClass).stream()
        .filter(field ->
            field.isAnnotationPresent(CreatedDate.class) || field.getName().contains("createdAt"))
        .findFirst()
        .orElse(null);
  }

  default boolean hasUniqueConstraints(Class<? extends T> targetClass) {
    return targetClass.getAnnotation(Table.class).uniqueConstraints().length > 0;
  }

  default boolean hasJoinColumns(Class<? extends T> targetClass) {
    return getFields(targetClass).stream()
        .anyMatch(field -> field.isAnnotationPresent(JoinColumn.class));
  }

  default List<Field> getFields(Class<? extends T> targetClass) {
    List<Field> consolidatedFields =
        new ArrayList<>(List.of(targetClass.getDeclaredFields()));

    Class<?> superClass = targetClass.getSuperclass();
    while (!superClass.equals(Object.class)) {
      consolidatedFields.addAll(List.of(superClass.getDeclaredFields()));
      superClass = superClass.getSuperclass();
    }

    return consolidatedFields.stream()
        .filter(field -> !field.isAnnotationPresent(Transient.class))
        .filter(field -> field.isAnnotationPresent(Column.class) ||
            field.isAnnotationPresent(JoinColumn.class))
        .collect(Collectors.toList());
  }

  default Map<String, String> getMappings(Class<? extends T> targetClass, boolean withId) {
    return getFields(targetClass).stream()
        .filter(field -> field.isAnnotationPresent(Column.class) ||
            field.isAnnotationPresent(JoinColumn.class))
        .filter(field -> withId || !field.isAnnotationPresent(Id.class))
        .collect(Collectors.toMap(
            field -> field.isAnnotationPresent(Column.class) ?
                field.getAnnotation(Column.class).name() :
                field.getAnnotation(JoinColumn.class).name(),
            Field::getName));
  }

  default Map<String, String> getUniqueConstraintColumns(Class<? extends T> targetClass) {
    Map<String, String> mappings = getMappings(targetClass, true);
    List<String> uniqueConstraintColumns =
        Arrays.stream(targetClass.getAnnotation(Table.class).uniqueConstraints())
            .map(UniqueConstraint::columnNames)
            .flatMap(Arrays::stream)
            .distinct()
            .collect(Collectors.toList());
    return mappings.entrySet().stream()
        .filter(entry -> uniqueConstraintColumns.contains(entry.getKey()))
        .collect(Collectors.toMap(Entry::getKey, Entry::getValue));
  }

  default Map<String, String> getIdMappings(Class<? extends T> targetClass) {
    return getFields(targetClass).stream()
        .filter(field -> !field.isAnnotationPresent(Transient.class))
        .filter(field -> field.isAnnotationPresent(Id.class))
        .collect(Collectors.toMap(
            field -> field.getAnnotation(Column.class).name(),
            Field::getName
        ));
  }

  default Map<String, String> getMappingsOutsideUniqueConstraints(Class<? extends T> targetClass,
      boolean withId) {
    Map<String, String> uniqueConstraints = getUniqueConstraintColumns(targetClass);
    return getMappings(targetClass, withId).entrySet().stream()
        .filter(entry -> !uniqueConstraints.containsKey(entry.getKey()))
        .collect(Collectors.toMap(Entry::getKey, Entry::getValue));
  }
}
