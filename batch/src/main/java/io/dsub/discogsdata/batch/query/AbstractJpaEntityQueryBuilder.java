package io.dsub.discogsdata.batch.query;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.persistence.Column;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.Table;
import javax.persistence.Transient;
import javax.persistence.UniqueConstraint;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;

// TODO: TEST
public abstract class AbstractJpaEntityQueryBuilder<T> implements JpaEntityQueryBuilder<T> {

  public Pattern CREATED_AT = Pattern.compile("^(createdAt)|(created_at)$");
  public Pattern LAST_MODIFIED_AT = Pattern.compile("^(lastModifiedAt)|(last_modified_at)$");

  @Override
  public boolean isCreatedAt(Field field) {
    return field.isAnnotationPresent(CreatedDate.class) ||
        CREATED_AT.matcher(field.getName()).matches();
  }

  @Override
  public boolean isLastModifiedAt(Field field) {
    return field.isAnnotationPresent(LastModifiedDate.class) ||
        LAST_MODIFIED_AT.matcher(field.getName()).matches();
  }

  @Override
  public boolean isDateTimeField(Field field) {
    return isCreatedAt(field) || isLastModifiedAt(field);
  }

  @Override
  public boolean isIdentifier(Field field) {
    return field.isAnnotationPresent(Id.class);
  }

  @Override
  public boolean isTransient(Field field) {
    return field.isAnnotationPresent(Transient.class);
  }

  @Override
  public boolean isColumn(Field field) {
    return field.isAnnotationPresent(Column.class);
  }

  @Override
  public boolean isJoinColumn(Field field) {
    return field.isAnnotationPresent(JoinColumn.class);
  }

  @Override
  public boolean isAutoGenerated(Field field) {
    return field.isAnnotationPresent(GeneratedValue.class);
  }

  @Override
  public boolean isAutoGeneratedId(Field field) {
    return isIdentifier(field) && isAutoGenerated(field);
  }

  @Override
  public boolean isMappedField(Field field) {
    if (isTransient(field)) {
      return false;
    }
    if (isColumn(field)) {
      return !field.getAnnotation(Column.class).name().isBlank();
    }
    if (isJoinColumn(field)) {
      return !field.getAnnotation(JoinColumn.class).name().isBlank();
    }
    return false;
  }

  @Override
  public Stream<Field> getFieldStream(Class<?> targetClass) {
    List<Field> fields = new ArrayList<>(List.of(targetClass.getDeclaredFields()));

    Class<?> superClass = targetClass.getSuperclass();
    while (!superClass.equals(Object.class)) {
      fields.addAll(Arrays.asList(superClass.getDeclaredFields()));
      superClass = superClass.getSuperclass();
    }
    return fields.stream()
        .filter(this::isMappedField);
  }

  @Override
  public Stream<Field> getFieldStream(Class<?> targetClass, boolean withId) {
    return getFieldStream(targetClass)
        .filter(field -> withId || !isIdentifier(field));
  }

  @Override
  public String getTableName(Class<?> targetClass) {
    return targetClass.getAnnotation(Table.class).name();
  }

  @Override
  public boolean isEntityIdNotManaged(Class<?> targetClass) {
    return getFieldStream(targetClass).anyMatch(this::isAutoGeneratedId);
  }

  @Override
  public String getValueMappedString(Class<?> targetClass, boolean withId) {
    return getFieldStream(targetClass)
        .filter(field -> withId || !isIdentifier(field))
        .map(field -> isDateTimeField(field) ? "NOW()" : COLON + field.getName())
        .collect(Collectors.joining(","));
  }

  @Override
  public List<String> getColumns(Class<?> targetClass, boolean withId) {
    return getFieldStream(targetClass, withId)
        .filter(this::isMappedField)
        .map(this::getColumnName)
        .collect(Collectors.toList());
  }

  @Override
  public List<String> getUniqueKeys(Class<?> targetClass) {
    if (isEntityIdNotManaged(targetClass)) {
      if (hasUniqueConstraintAnnotation(targetClass)) {
        return getUniqueConstraintsAnnotationNames(targetClass);
      }
    }
    return getIdColumnNames(targetClass);
  }

  @Override
  public List<String> getIdColumnNames(Class<?> targetClass) {
    return getFieldStream(targetClass)
        .filter(this::isIdentifier)
        .map(Field::getName)
        .collect(Collectors.toList());
  }

  @Override
  public List<String> getUniqueConstraintsColumns(Class<?> targetClass) {
    Set<String> constraintsFromColumns = getFieldStream(targetClass)
        .filter(field -> field.isAnnotationPresent(UniqueConstraint.class))
        .map(field -> field.getAnnotation(UniqueConstraint.class).columnNames())
        .flatMap(Arrays::stream)
        .collect(Collectors.toSet());
    Set<String> consolidated = Arrays
        .stream(targetClass.getAnnotation(Table.class).uniqueConstraints())
        .map(UniqueConstraint::columnNames)
        .flatMap(Arrays::stream)
        .collect(Collectors.toSet());
    consolidated.addAll(constraintsFromColumns);
    return new ArrayList<>(consolidated);
  }

  @Override
  public List<String> getUniqueConstraintsColumnsAndFields(Class<?> targetClass) {
    List<String> mustUniqueColumns = getUniqueConstraintsColumns(targetClass);
    return getFieldStream(targetClass)
        .filter(field -> mustUniqueColumns.contains(getColumnName(field)))
        .map(field -> getColumnName(field) + EQUALS + COLON + field.getName())
        .collect(Collectors.toList());
  }

  @Override
  public List<String> getUniqueConstraintsAnnotationNames(Class<?> targetClass) {
    List<String> uniqueConstraints = new ArrayList<>();
    UniqueConstraint constraint = targetClass.getAnnotation(UniqueConstraint.class);
    if (constraint != null) {
      uniqueConstraints.add(constraint.name());
    }
    Arrays.stream(targetClass.getAnnotation(Table.class).uniqueConstraints())
        .map(UniqueConstraint::name)
        .forEach(uniqueConstraints::add);
    return uniqueConstraints;
  }

  @Override
  public boolean hasUniqueConstraintAnnotation(Class<?> targetClass) {
    if (targetClass.isAnnotationPresent(UniqueConstraint.class)) {
      return true;
    }
    return targetClass.getAnnotation(Table.class).uniqueConstraints().length > 0;
  }

  @Override
  public String getColumnName(Field field) {
    if (field.isAnnotationPresent(Column.class)) {
      return field.getAnnotation(Column.class).name();
    }
    return field.getAnnotation(JoinColumn.class).name();
  }

  @Override
  public Map<String, String> getIdColumnAndFields(Class<?> targetClass) {
    return getFieldStream(targetClass, true)
        .filter(this::isIdentifier)
        .collect(Collectors.toMap(
            field -> field.getAnnotation(Column.class).name(),
            Field::getName));
  }
}
